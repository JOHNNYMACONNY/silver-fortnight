rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function hasRole(role) {
      return isAuthenticated() &&
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.roles.hasAny([role]);
    }

    function isAdmin() {
      return hasRole('admin');
    }

    function isModerator() {
      return hasRole('moderator') || isAdmin();
    }

    function isValidTimestamp(ts) {
      return ts is timestamp &&
        ts.date() <= request.time.date();
    }

    function validateUserData(data) {
      return data.size() <= 1000000 && // 1MB limit
             data.name is string &&
             data.email is string &&
             data.createdAt is timestamp &&
             (!('roles' in data) || isAdmin());
    }

    function validateTradeData(data) {
      return data.creatorId == request.auth.uid &&
             data.createdAt is timestamp &&
             data.status in ['pending', 'active', 'completed', 'cancelled'] &&
             data.participantIds is list &&
             data.participantIds.size() >= 2 &&
             data.participantIds.size() <= 10;
    }

    function validateTradeUpdate(old, new) {
      let validTransitions = {
        'pending': ['active', 'cancelled'],
        'active': ['completed', 'cancelled'],
        'completed': [],
        'cancelled': []
      };
      return old.creatorId == new.creatorId &&
             old.participantIds == new.participantIds &&
             new.status in validTransitions[old.status];
    }

    function isTradeParticipant(trade) {
      return (
        (trade.data.participantIds is list && trade.data.participantIds.hasAny([request.auth.uid])) ||
        (trade.data.participants is map && (
          (trade.data.participants.creator == request.auth.uid) ||
          (trade.data.participants.participant == request.auth.uid)
        ))
      );
    }

    function isParticipant(data) {
      return (
        (data.participantIds is list && data.participantIds.hasAny([request.auth.uid])) ||
        (data.participants is map && (
          (data.participants.creator == request.auth.uid) ||
          (data.participants.participant == request.auth.uid)
        ))
      );
    }

    // Helper function to check if user is participant in a conversation document
    // Optimized version that avoids expensive get() calls where possible
    function isConversationParticipant(conversationId) {
      // Try to get conversation data, but handle failures gracefully
      return exists(/databases/$(database)/documents/conversations/$(conversationId)) &&
             isParticipant(get(/databases/$(database)/documents/conversations/$(conversationId)).data);
    }

    // Fast participant check for message operations (avoids get() when possible)
    function isMessageParticipant(conversationId, messageData) {
      // If message has sender info, check if current user is sender
      return (messageData.senderId == request.auth.uid) ||
             // Otherwise fall back to conversation participant check
             isConversationParticipant(conversationId);
    }

    // User profiles
    match /users/{userId} {
      // Allow authenticated users to read basic profile info needed for messaging
      // This enables proper display names and avatars in conversations
      // while still protecting sensitive data through field-level restrictions
      allow read: if isAuthenticated() ||
                     (resource.data != null && resource.data.public == true) ||
                     isOwner(userId) ||
                     isAdmin();
      allow create: if request.auth.uid == userId && validateUserData(request.resource.data);
      allow update: if ( (request.auth.uid == userId && validateUserData(request.resource.data)) || isAdmin());
      allow delete: if isAdmin();

      // Private user data (e.g., settings, sensitive info)
      match /private/{document=**} {
        allow read, write: if isOwner(userId);
      }

      // Connections subcollection - user connections/friendships
      match /connections/{connectionId} {
        allow read: if isAuthenticated() && (
          userId == request.auth.uid || // User can read their own connections
          isAdmin()
        );
        allow create: if isAuthenticated() && (
          userId == request.auth.uid || // User can create connections in their own subcollection
          (request.resource.data.senderId == request.auth.uid) // Or sender can create in recipient's subcollection
        );
        allow update: if isAuthenticated() && (
          userId == request.auth.uid || // User can update connections in their own subcollection
          resource.data.connectedUserId == request.auth.uid || // Connected user can update (accept/reject)
          resource.data.senderId == request.auth.uid || // Sender can update their sent connections
          resource.data.receiverId == request.auth.uid || // Receiver can update received connections
          isAdmin()
        );
        allow delete: if isAuthenticated() && (
          userId == request.auth.uid || // User can delete connections in their own subcollection
          resource.data.connectedUserId == request.auth.uid || // Connected user can delete
          isAdmin()
        );
      }
    }

    // Trade records
    match /trades/{tradeId} {
      // Require authentication to read trade records by default. Public trades can set a `visibility` field = 'public'
      allow read: if isAuthenticated() || (resource.data != null && resource.data.visibility == 'public');
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.creatorId;
      // Ensure correct operator precedence: either the authenticated creator OR an admin may update/delete
      allow update, delete: if (isAuthenticated() && request.auth.uid == resource.data.creatorId) || isAdmin();

      // Proposals subcollection
      match /proposals/{proposalId} {
  // Proposals should be visible to authenticated users or explicitly public
  allow read: if isAuthenticated() || (resource.data != null && resource.data.visibility == 'public');
        allow create: if isAuthenticated();
        allow update, delete: if false;
      }

      // Messages subcollection
      match /messages/{messageId} {
        allow read: if isAuthenticated() && isParticipant(get(/databases/$(database)/documents/trades/$(tradeId)).data);
        allow create: if isAuthenticated() && isParticipant(get(/databases/$(database)/documents/trades/$(tradeId)).data);
        allow update, delete: if false;
      }

      // Evidence subcollection
      match /evidence/{evidenceId} {
        allow read: if isAuthenticated() && isParticipant(get(/databases/$(database)/documents/trades/$(tradeId)).data);
        allow create: if isAuthenticated() && request.resource.data.uploaderId == request.auth.uid;
        allow delete: if isModerator();
      }
    }

    // Conversations (legacy chat data)
    match /conversations/{conversationId} {
      // Temporarily allow all authenticated users to read/list conversations
      // TODO: Implement proper participant checking after debugging
      allow read, list: if isAuthenticated();

      // Only participants can update or delete the conversation
      allow update, delete: if isAuthenticated() && (
        isParticipant(resource.data) ||
        isAdmin()
      );
      // Any authenticated user can create a conversation
      allow create: if isAuthenticated();

      // Messages subcollection
      match /messages/{messageId} {
        // Allow participants to read messages - optimized for performance
        allow read: if isAuthenticated() && (
          // Fast check: if user is message sender (avoids expensive get() call)
          (resource != null && resource.data.senderId == request.auth.uid) ||
          // Fallback: check conversation participation (slower)
          isConversationParticipant(conversationId) ||
          isAdmin()
        );
        // Allow participants to create messages - optimized for performance
        allow create: if isAuthenticated() && (
          // Fast check: if user is creating their own message
          (request.resource.data.senderId == request.auth.uid) ||
          // Fallback: check conversation participation
          isConversationParticipant(conversationId) ||
          isAdmin()
        );
        // Allow participants to update read receipts - secure rule that works with arrayUnion
        // This rule works with Firestore's arrayUnion() operations while maintaining security
        allow update: if isAuthenticated() &&
           // Only allow updating readBy field (prevents unauthorized field changes)
           request.resource.data.diff(resource.data).changedKeys().hasOnly(['readBy']) &&
           // Ensure user is authenticated
           request.auth != null;
        // Messages cannot be deleted
        allow delete: if false;
      }
    }

    // Flat messages collection (for direct queries) - DEPRECATED
    // This collection is maintained for backward compatibility only
    // New messages should use nested subcollections: conversations/{conversationId}/messages/{messageId}
    match /messages/{messageId} {
      allow read, create: if isAuthenticated() &&
        resource.data.conversationId != null &&
        exists(/databases/$(database)/documents/conversations/$(resource.data.conversationId)) &&
        isConversationParticipant(resource.data.conversationId);
      allow update, delete: if false; // Messages are immutable
    }

    // System settings
    match /settings/{document=**} {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // Audit logs
    match /audit/{logId} {
      allow read: if isModerator();
      allow create: if isAuthenticated();
      allow update, delete: if false; // Audit logs are immutable
    }

    // Rate limiting
    match /ratelimits/{userId} {
      allow read: if isOwner(userId);
      allow write: if false; // Only managed by server
    }

    // Migration progress tracking
    match /migration-progress/{migrationId} {
      allow read, write: if isAdmin();
    }

    // Migration system collections (for migration scripts with service account)
    match /migration-system/{document=**} {
      allow read, write: if false; // Only accessible via service account
    }

    // Migration audit logs
    match /migration-audit/{logId} {
      allow read: if isAdmin();
      allow create: if isAuthenticated();
      allow update, delete: if false; // Audit logs are immutable
    }

    // Collaborations
    match /collaborations/{collaborationId} {
      // Require authentication to read collaborations by default; allow explicit public flag
      allow read: if isAuthenticated() || (resource.data != null && resource.data.public == true);
      allow create: if isAuthenticated();
      allow update, delete: if isAuthenticated() && (resource.data.creatorId == request.auth.uid || isAdmin());

      // Roles subcollection
      match /roles/{roleId} {
  // Roles are visible to authenticated users or explicitly public
  allow read: if isAuthenticated() || (resource.data != null && resource.data.public == true);
        allow create, delete: if isAuthenticated() && (get(/databases/$(database)/documents/collaborations/$(collaborationId)).data.creatorId == request.auth.uid || isAdmin());
        allow update: if isAuthenticated() && (
          get(/databases/$(database)/documents/collaborations/$(collaborationId)).data.creatorId == request.auth.uid ||
          isAdmin() ||
          (resource.data.participantId == request.auth.uid)
        );

        // Applications subcollection
        match /applications/{applicationId} {
          // Allow collaboration creator to read all applications
          // Also allow any authenticated user to read applications for debugging
          allow read: if isAuthenticated();
          allow create: if isAuthenticated() && request.resource.data.applicantId == request.auth.uid;
          allow update: if isAuthenticated() && (
            resource.data.applicantId == request.auth.uid ||
            get(/databases/$(database)/documents/collaborations/$(collaborationId)).data.creatorId == request.auth.uid ||
            isAdmin()
          );
          allow delete: if isAuthenticated() && resource.data.applicantId == request.auth.uid && resource.data.status == 'pending';
        }
      }

      // Messages subcollection
      match /messages/{messageId} {
  // Collaboration messages should be visible to authenticated users or to explicitly public messages
  allow read: if isAuthenticated() || (resource.data != null && resource.data.public == true);
        allow create: if isAuthenticated();
        allow update, delete: if false;
      }

      // Completion requests subcollection
      match /completionRequests/{requestId} {
        allow read: if isAuthenticated() && (
          get(/databases/$(database)/documents/collaborations/$(collaborationId)).data.creatorId == request.auth.uid ||
          resource.data.requesterId == request.auth.uid ||
          isAdmin()
        );
        allow create: if isAuthenticated() && request.resource.data.requesterId == request.auth.uid;
        allow update, delete: if false;
      }
    }

    // Challenges
    match /challenges/{challengeId} {
      // Allow authenticated users to read challenges; allow public flag for anonymous access
      allow read: if isAuthenticated() || (resource.data != null && resource.data.public == true);
      allow create: if isAuthenticated();
      // Allow updates by creator/admin OR for specific fields that users can modify when joining/leaving
      allow update: if isAuthenticated() && (
        resource.data.creatorId == request.auth.uid ||
        isAdmin() ||
        // Allow updating participant count and updatedAt when joining/leaving challenges
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['participantCount', 'updatedAt']))
      );
      allow delete: if isAuthenticated() && (resource.data.creatorId == request.auth.uid || isAdmin());
    }

    // User Challenges - for tracking user participation in challenges
    // Document ID format: ${userId}_${challengeId}
    match /userChallenges/{userChallengeId} {
      // Allow users to read their own challenge participation records
      // Check both document data and document ID pattern for authorization
      allow read: if isAuthenticated() && (
        (resource != null && resource.data.userId == request.auth.uid) ||
        userChallengeId.matches('^' + request.auth.uid + '_.*$') ||
        isAdmin()
      );
      // Allow users to create their own challenge participation records
      allow create: if isAuthenticated() && (
        request.resource.data.userId == request.auth.uid ||
        userChallengeId.matches('^' + request.auth.uid + '_.*$') ||
        isAdmin()
      );
      // Allow users to update their own challenge progress
      allow update: if isAuthenticated() && (
        (resource != null && resource.data.userId == request.auth.uid) ||
        userChallengeId.matches('^' + request.auth.uid + '_.*$') ||
        isAdmin()
      );
      // Only admins can delete challenge records
      allow delete: if isAdmin();
    }

    // Three-Tier Progress - for tracking user progression through challenge tiers
    match /threeTierProgress/{userId} {
      // Allow users to read their own progression status
      allow read: if isAuthenticated() && (
        userId == request.auth.uid || isAdmin()
      );
      // Allow users to create their own progression record
      allow create: if isAuthenticated() && (
        userId == request.auth.uid || isAdmin()
      );
      // Allow users to update their own progression
      allow update: if isAuthenticated() && (
        userId == request.auth.uid || isAdmin()
      );
      // Only admins can delete progression records
      allow delete: if isAdmin();
    }

    // Skill Assessments - for tracking user skill evaluation data
    match /skillAssessments/{assessmentId} {
      // Allow users to read their own skill assessments
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || isAdmin()
      );
      // Allow users to create their own skill assessments
      allow create: if isAuthenticated() && (
        request.resource.data.userId == request.auth.uid || isAdmin()
      );
      // Allow users to update their own assessments
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || isAdmin()
      );
      // Only admins can delete assessments
      allow delete: if isAdmin();
    }

    // User Skills - for tracking individual skill progression and XP
    match /userSkills/{skillId} {
      // Allow users to read their own skill records
      // skillId format is typically `${userId}_${skillName}`
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        skillId.matches('^' + request.auth.uid + '_.*$') ||
        isAdmin()
      );
      // Allow users to create their own skill records
      allow create: if isAuthenticated() && (
        request.resource.data.userId == request.auth.uid ||
        skillId.matches('^' + request.auth.uid + '_.*$') ||
        isAdmin()
      );
      // Allow users to update their own skill progression
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        skillId.matches('^' + request.auth.uid + '_.*$') ||
        isAdmin()
      );
      // Only admins can delete skill records
      allow delete: if isAdmin();
    }

    // Challenge Submissions - for tracking user submissions to challenges
    match /challengeSubmissions/{submissionId} {
      // Allow users to read their own submissions and submissions to challenges they participate in
      allow read: if isAuthenticated() && (
        (resource != null && resource.data.userId == request.auth.uid) ||
        isAdmin()
      );
      // Allow users to create their own challenge submissions
      allow create: if isAuthenticated() && (
        request.resource.data.userId == request.auth.uid || isAdmin()
      );
      // Allow users to update their own submissions
      allow update: if isAuthenticated() && (
        (resource != null && resource.data.userId == request.auth.uid) || isAdmin()
      );
      // Only admins can delete submissions
      allow delete: if isAdmin();
    }

    // Notifications
    match /notifications/{notificationId} {
      // Only the owner (userId or recipientId) or an admin can read
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.recipientId == request.auth.uid ||
        isAdmin()
      );
      // Only the owner (userId or recipientId) or admin can create
      allow create: if isAuthenticated() && (
        request.resource.data.userId == request.auth.uid ||
        request.resource.data.recipientId == request.auth.uid ||
        isAdmin()
      );
      // Only the owner or admin can update/delete
      allow update, delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.recipientId == request.auth.uid ||
        isAdmin()
      );
    }

    // User XP Collection - for gamification (readable by all authenticated users for leaderboards)
    match /userXP/{userId} {
      allow read: if isAuthenticated(); // Allow reading for leaderboards
      allow create, update: if isAuthenticated() && (
        userId == request.auth.uid || isAdmin()
      );
      allow delete: if isAdmin();
    }

    // XP Transactions Collection - for tracking XP history
    match /xpTransactions/{transactionId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || isAdmin()
      );
      allow create: if isAuthenticated() && (
        request.resource.data.userId == request.auth.uid || isAdmin()
      );
      allow update, delete: if isAdmin();
    }

    // User Achievements - unlocked achievements by user
    match /userAchievements/{id} {
      // Owner or admin can read; needed for admin metrics across users
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || isAdmin()
      );
      // Only owner can create their own achievement record; admin may write via backend tools
      allow create: if isAuthenticated() && (
        request.resource.data.userId == request.auth.uid || isAdmin()
      );
      // Admin-only updates/deletes (clients should not update/delete achievements)
      allow update, delete: if isAdmin();
    }


    // Connections Collection - for user connections/friendships
    match /connections/{connectionId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.connectedUserId == request.auth.uid ||
        isAdmin()
      );
      allow create: if isAuthenticated() && (
        request.resource.data.userId == request.auth.uid
      );
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.connectedUserId == request.auth.uid ||
        isAdmin()
      );
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.connectedUserId == request.auth.uid ||
        isAdmin()
      );
    }

    // User Follows Collection - for leaderboard following
    match /userFollows/{followId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && (
        request.resource.data.followerId == request.auth.uid
      );
      allow update, delete: if isAuthenticated() && (
        resource.data.followerId == request.auth.uid || isAdmin()
      );
    }

    // Leaderboards Collection - for leaderboard data (read-only for users)
    match /leaderboards/{leaderboardId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isAdmin();
    }

    // Leaderboard Stats Collection - for time-period specific leaderboard data
    // Document ID format: ${userId}_${period}_${periodStart}
    match /leaderboardStats/{statId} {
      allow read: if isAuthenticated(); // Allow all authenticated users to read leaderboard stats
      // Allow users to create/update their own leaderboard stats when earning XP
      allow create, update: if isAuthenticated() && (
        (resource != null && resource.data.userId == request.auth.uid) ||
        (request.resource.data.userId == request.auth.uid) ||
        statId.matches('^' + request.auth.uid + '_.*$') ||
        isAdmin()
      );
      allow delete: if isAdmin();
    }

    // User Stats Collection - for trade counts, collaboration ratings, etc.
    match /userStats/{userId} {
      allow read: if isAuthenticated(); // Allow reading for leaderboards
      allow create, update: if isAuthenticated() && (
        userId == request.auth.uid || isAdmin()
      );
      allow delete: if isAdmin();
    }

    // User Streaks Collection - for login/challenge/skill streaks
    // Document IDs are formatted as `${userId}_${type}` so we can authorize via path variable
    match /userStreaks/{streakId} {
      // Only the owner of the streak can read or write their own streak documents
      allow read, create, update: if isAuthenticated() && streakId.matches('^' + request.auth.uid + '_.*$');
      // Do not allow deletes from client
      allow delete: if false;
    }

    // Social Stats Collection - for social features and leaderboard appearances
    match /socialStats/{userId} {
      allow read: if isAuthenticated(); // Allow reading for social features
      allow create, update: if isAuthenticated() && (
        userId == request.auth.uid || isAdmin()
      );
      allow delete: if isAdmin();
    }

    // Performance Metrics Collection - for RUM data collection
    match /performance_metrics/{metricId} {
      allow read: if isAdmin();
      allow create: if isAuthenticated();
      allow update, delete: if isAdmin();
    }
  }
}