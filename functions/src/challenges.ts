import * as functions from 'firebase-functions';
import { db, withRetry } from './firebase';
import { DocumentSnapshot } from 'firebase-admin/firestore';

interface Challenge {
  id: string;
  title: string;
  description: string;
  type: 'weekly' | 'monthly';
  status: 'pending' | 'live' | 'archived';
  requirements: {
    type: string;
    count: number;
    skillCategory: string;
  }[];
  rewards: {
    xp: number;
    badge: string;
  };
  startDate: Date | null;
  endDate: Date | null;
  createdAt: Date;
  updatedAt: Date;
}


// Function to archive expired challenges
export const archiveExpiredChallenges = functions.pubsub.schedule('every 1 hours').timeZone('UTC').onRun(async () => {
  const now = new Date();
  
  // Get live challenges that have passed their end date
  const expiredSnapshot = await db.collection('challenges')
    .where('status', '==', 'live')
    .where('endDate', '<', now)
    .get();

  if (expiredSnapshot.empty) {
    console.log('No expired challenges found');
    return null;
  }

  const batch = db.batch();
  let archivedCount = 0;

  expiredSnapshot.docs.forEach((doc: DocumentSnapshot) => {
    batch.update(doc.ref, {
      status: 'archived',
      updatedAt: now
    });
    archivedCount++;
  });

  await batch.commit();
  console.log(`Archived ${archivedCount} expired challenges`);

  // Trigger generation of new challenges if needed
  const liveSnapshot = await db.collection('challenges')
    .where('status', 'in', ['live', 'pending'])
    .get();

  if (liveSnapshot.size < 20) { // We maintain 20 total challenges (10 weekly + 10 monthly)
    // Count existing challenges by type
    const counts = { weekly: 0, monthly: 0 };
    liveSnapshot.docs.forEach((doc: DocumentSnapshot) => {
      const data = doc.data();
      const type = data?.type;
      if (type === 'weekly' || type === 'monthly') {
        counts[type as keyof typeof counts]++;
      }
    });

    // Log if new challenges are needed
    if (counts.weekly < 10) {
      console.log('Fewer than 10 weekly challenges - new ones will be generated by Netlify function');
    }
    if (counts.monthly < 10) {
      console.log('Fewer than 10 monthly challenges - new ones will be generated by Netlify function');
    }
  }

  return null;
});

// Function to activate pending challenges
export const activateChallenges = functions.pubsub.schedule('every 1 hours').onRun(async () => {
  const now = new Date();
  
  // Get pending challenges
  const pendingSnapshot = await db.collection('challenges')
    .where('status', '==', 'pending')
    .get();

  const batch = db.batch();
  let activatedCount = 0;

  pendingSnapshot.docs.forEach((doc: DocumentSnapshot) => {
    const challenge = doc.data() as Challenge;
    const startDate = new Date();
    const endDate = new Date(startDate);
    if (challenge.type === 'weekly') {
      endDate.setDate(endDate.getDate() + 7);
    } else {
      endDate.setMonth(endDate.getMonth() + 1);
    }

    batch.update(doc.ref, {
      status: 'live',
      startDate,
      endDate,
      updatedAt: now
    });
    
    activatedCount++;
  });

  if (activatedCount > 0) {
    await batch.commit();
    console.log(`Activated ${activatedCount} challenges`);
  }
});

// HTTP function for manual challenge activation
export const manuallyActivateChallenge = functions.https.onCall(async (data: { challengeId: string }, context) => {
  // Verify admin status
  if (!context.auth?.token.admin) {
    throw new functions.https.HttpsError(
      'permission-denied',
      'Only admins can manually activate challenges'
    );
  }

  const { challengeId } = data;
  if (!challengeId) {
    throw new functions.https.HttpsError(
      'invalid-argument',
      'Challenge ID is required'
    );
  }

  const challengeRef = db.collection('challenges').doc(challengeId);
  const challenge = await challengeRef.get();

  if (!challenge.exists) {
    throw new functions.https.HttpsError(
      'not-found',
      'Challenge not found'
    );
  }

  const challengeData = challenge.data() as Challenge;
  if (challengeData?.status !== 'pending') {
    throw new functions.https.HttpsError(
      'failed-precondition',
      'Challenge is not in pending status'
    );
  }

  const now = new Date();
  const endDate = new Date(now);
  if (challengeData.type === 'weekly') {
    endDate.setDate(endDate.getDate() + 7);
  } else {
    endDate.setMonth(endDate.getMonth() + 1);
  }

  await challengeRef.update({
    status: 'live',
    startDate: now,
    endDate,
    updatedAt: now
  });

  return { success: true };
});
